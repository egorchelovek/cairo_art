Рекурсивные алгоритмы на PHP. Часть 2. Основы рекурсии в PHP

Ханойская башня

Давным-давно, в храме города Бенарес Великий Брама, в наказание трёх провинившихся священников,
на ступенях алтаря воздвиг три высоких алмазных стержня
и на одном из них сложил башню из шестдесяти четырех дисков,
сделанных из чистого золота - каждый верхний диск на размер меньше нижнего.
И повелел священникам переместить диски с одного стержня на другой выполняя следующие правила:
1) В одно время можно брать только один диск.
2) Нельзя класть больший диск на меньший.
Пророчество гласит: когда последний ход головоломки будет завершен - башня падет и настанет Конец Света.

Такова легенда одной из самых известных математических головоломок. Если предположить что пророчество верно
и священники перемещают диски со скоростью 1 диск/сек, то впереди нас ждет ещё 41 цикл длительностью в 13.7 млрд. лет. Чтож, потратим это время с умом! И посмотрим что может поведать нам эта головоломка о рекурсии и её смысле...

И для начала мы рассмотрим итеративное решение этой задачи. Для того чтобы получить его, нам нужно рассмотреть
пару конретных примеров для различного числа дисков n, чтобы увидеть неявные закономерности в перемещении дисков,
которые возникают при соблюдении правил Брамы.

Пусть у нас есть три стержня А, B и С, причем стержень A - это стержень на котором расположены диски в начале.
Стрежень B это промежуточный стержень. И стержень C - это стержень на котором должны оказаться диске в самом конце.
Тогда запишем первые несколько решений этой головоломки для разных n.

1 A->C
2 A->B A->C B->C
3 A->C A->B C->B A->C B->A B->C A->C

Здесь операция X->Y означает что нужно взять диск со стержня X и поместить на стержень Y.
Очевидна следующая закономерность - количество необходимых ходов для решения равно 2^n - 1.
Это утверждение можно доказать следуя математической индукции, но мы не будем с вами этого делать,
так как это не входит в нашу цель изучения рекурсии на PHP.

Обнаружить ещё одну закономерность в этих данных гораздо сложнее, поэтому решим ещё эту головоломку
для n = 4.

4 A->B A->C B->C A->B C->A C->B A->B A->C B->C B->A C->A B->C A->B A->C B->C
  1    2    3    1    2    3    1    2    3    1    2    3    1    2    3
Если пронумеровать каждую пару индексом от 1 до 3-х мы можем заметить, что
одни и теже пары стержней будут иметь одинаковый индекс.
Таким образом перемещения между одинаковыми парами дисков повторяются раз в три хода.
Это так же можно доказать согласно принципу математической индукции, но мы вернёмся к нашей задаче.

Теперь когда мы обнаружили эти две закономерности мы можем записать их в виде кода:

towers_iter.php

Здесь есть ещё один участок, который отвечает за то, чтобы при четном количестве дисков стержни B и С
поменялись местами. Эта третья закономерность, которая прячется на виду, и её легко не заметить.

К сожалению этот алгорим может выдать нам только пары стержений между которыми нужно совершать перемещения,
без указания направления перемещения дисков. А для того, чтобы указать направление,
в этот алгоритм нужно добавить первоначальные правила Брамы. И чтобы это сделать нам придётся
внедрить в наш код объектную модель самой задачи.

Каждый маг строит башню, чем больше башня - тем больше сила мага.

Теперь, когда объектная модель готова. Мы можем запустить наш алгоритм и проверить его работу
для всех приведённых случаев.

A->B A->C B->C A->B C->A C->B A->B A->C B->C B->A C->A B->C A->B A->C B->C

Отлично, алгоритм работает правильно. Мы затратили уйму времени и строк, чтобы написать этот алгоритм.

А теперь сравним этот алгоритм с его рекурсивной версией.
Стандартное решение состоит в том, чтобы переместить n-1 диск со начального стержня A на промежуточный стержень B,
затем переместить диск с диска А на конечный диск C, и после переместить оставшиеся диски с диска B на диск C.
Эти три этапа отражены в следующем коде.

towers.php

Чтож, он выглядит гораздо проще: почти в десять раз компактнее его итеративной версии. Это одно
из преимуществ рекурсии, которое имеет множество последствий. В некоторых случаях выгоднее писать рекурсивный код,
так как его будет легче поддерживать, он будет выглядеть лаконично, его будет легче понять, а так же легче
заниматься его отладкой и он займёт меньше времени на разработку, то есть это даёт возможность сэкономить личное время.

Теперь сравним время выполнения этих двух алгоритмов.


Мы видим, что при больших значениях n рекурсивный код выигрывает по времени.
Это второе преимущество, которое может быть существенным при разработке высконагруженных систем,
когда дорога каждая секунда процессорного времени. В некоторых случаях рекурсивный код
может работать быстрее его итеративных аналогов и это даёт возможность сэкономить вычислительные ресурсы.

Очевидно так же что для нашей задачи рекурсивное решение более экономично в плане затрат компьютерной памяти,
так как не требует хранения объектной модели. Это может быть третьим преимуществом рекурсии.

Итак подведём итоги. Мы изучили различные аспекты реализации рекурсивных алгоритмов на PHP. Теперь мы знаем:
1) Что такое рекурсия и какие виды рекурсии бывают. (Читать с начала первой части)

2) Применяя рекурсию нужно быть осторожным, т.к.
есть вероятность переполнения стека рекурсивных вызовов
при больших значениях глубины рекурсии или в случае бесконечной рекурсии.

3) В некоторых случаях рекурсивные алгоритмы могут работать медленнее их итеративных аналогов
(Вычисления последовательности чисел Фибоначи и т.п.),

4) Для достижения большей эффективности следует
-использовать подход восходящего динамического программирования
Задача разбивается на подзадачи и каждая подзадача решается только один раз.
-использовать ООП для того, чтобы избежать затрат на копирование аргументов в стеке

5) В общем и целом рекурсия позволяет абстрагироваться от конкретных деталей задачи при её решении.
В следствии этого это может помочь нам:
сэкономить личное время и ресурсы
сэкономить вычислительные ресурсы такие как память и процессорное время.


В заключении я хочу отметить, что тема рекурсии далеко не исчерпана и мы встретимся с ней снова
в наших статьях, когда речь зайдёт о фракталах.




.
