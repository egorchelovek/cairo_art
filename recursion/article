Рекурсивные алгоритмы на php. Часть I



Понятие рекурсии

Для начала разберёмся с понятием рекурсии.
В общем смысле рекурсия это отображение чего-либо внутри самого себя.
Рекурсивные алгоритмы используют рекурсивные функции, обладающие данным свойством.
Существует два варианта реализации рекурсивных функций: простой и сложный.
В простом случае рекурсивная функция вызывает саму себя.
В сложном - функция вызывает другую функцию, которая вызывает исходную функцию,
с которой всё началось.

Рассмотрим пример из жизни. Если взять два больших зеркала и поставить их друг на против друга,
то можно увидеть бесконечный корридор из изображений зеркал. Каждое зеркало несёт в себе функцию отображения
пространства расположенного перед ним. Поэтому здесь мы имеем пример сложной рекурсии
(функция вызывает другую функцию, которая вызывает исходную).

Другим примером можно взять всем хорошо известное детское стихотворение:
"У попа была собака, он её любил,
Она съела кусок мяса, поп её убил,
В землю закопал,
И надпись написал о том, что
"У попа была собака, поп её любил,
Она съела кусок мяса, он её убил,
В землю закопал,
И надпись написал, что:
Эта докучная сказка представляет собой пример простой рекурсии (здесь функция вызывает саму себя).



Глубина рекурсии

В связи с понятием рекурсии возникает понятие глубины рекурсии, то есть степени вложенности её отображений.
Русская матрёшка как правило имеет 3-х и более вложенных в неё матрёшек.
То есть глубина рекурсии в данном случае равна количеству вложенных матрёшек. Глубина рекурсии может быть
равна бесконечности, в этом случае говорят о бесконечной рекусии. Два примера выше иллюстрируют именно этот случай.
Правда в реальном мире, в отличие от мира математических абстракций, всегда есть какие-либо ограничения.
Нельзя например бесконечно пересказывать одно и тоже стихотворение, так как мы ограничены во времени.

Для нас важно, что ограничениям подвержен и сам компьютер.
Память компьютера, производительность - не бесконечны.
Поэтому применяя рекурсию, нужно понимать её опасности и подводные камни.



Опасности и подводные камни рекурсии. Segmentation fault

Рассмотрим простой пример.

overflow.php

Здесь функция foo() должна вызывать самое себя до бесконечности.
В реальных условиях запуск программы приведёт к Segmentation fault, так как
произойдёт переполнение стека вызова в силу ограничений на выделенную под него память.
Понимая это следует избегать таких конструкций при разработке.

Тоже самое касается и примера со сложной рекурсией.

foo_bar.php

В PHP две функции не могут вызывать друг друга бесконечно, так как это неизбежно
приведёт к падению программы.

Теперь вернёмся к понятию глубины рекурсии. И рассмотрим следущий пример.

big_n.php

Здесь рекурсивный вызов должен завершиться по достижении степени вложенности $n.
На практике при запуске этой программы для больших значений $n произойдёт таже
самая ошибка переполнения стека. Это так же следует учитывать при обработке больших списков и
других структур данных в которых глубина рекурсии зависит от их размера.



Рекурсивные алгоритмы на PHP

Теперь мы можем приступить к исследованию алгоритмов основанных на рекурсии.
Существует множество таких алгоритмов. К примеру
Нахождение факториала
Вычисление последовательности Фибоначи
Поиск максимального элемента в массиве
Вычисление перестановок Ханойских башен
Рассчёт вариантов размена суммы монетами
Рекурсивный обход дерева
""

Рассмотрим некоторые из них.



Вычисление последовательности Фибоначи.

Следует сделать лирическое отступление, которое касается истории открытия данной последовательности.
В 1202 Леонардо Пизанский, известный как Фибоначи, решая задачу о размножении кроликов,
пришёл к открытию реккурентного соотношения:
F_n = F_{n-2} + F_{n-1}.

Эта последовательность обладает одним замечательным свойством, а именно:
\lim_{n\to\infty} \frac{F_{n+1}}{F_n} = \Phi.

Число Фи, представляет собой золотую пропорцию, которая часто встречается в природе, выражая
собой закон гармонии и красоты...

Вернёмся к нашему алгоритму. Знание рекуррентного соотношения позволяет нам с лёгкостью реализовать
этот алгоритм на PHP.

fibonachi.php

С точки зрения программирования нам интересно насколько быстро он выполняется по сравнению с него
реализацией на основе итераций. К примеру

fibonachi_iter.php

Если сделать тест выполнения с замером времени с помощью функции microtime, то обнаружиться, что
итеративная версия алгоритма выполняется гораздо быстрее, нежели его рекурсивный аналог.
Почему это происходит?

Дело в том, что реализация рекурсивного алгоритма "в лоб" обладает одним существенным недостатком.
А именно при такой реализации вызов функции для одного и того же аргумента производится многократно,
Чтобы это увидеть, нужно внимательно рассмотреть само рекурентное соотношение.
Это занимает дополнительное время пропорциональное количеству повторных вызовов.
Чтобы избежать этого используют подход восходящего динамического программирования, который состоит в том,
что задача разбивается на подзадачи и каждая подзадача решается только один раз.
В нашем примере это можно реализовать в виде:

fibonachi_dyn.php

Таким образом вызов функций над одним и тем же аргументом производится лишь однажды, в случае повторных
вызовов производится обращение к памяти к уже вычисленным значениям. Такой алгоритм выполняется гораздо
быстрее, чем его простая реализация. Но всё же при этом он значительно уступает итеративной версии.
В чём дело?

Оказывается, что при рекурсивном вызове функций создаются копии её аргументов в стеке
и следовательно дополнительные затраты на время выполнения.
Чтобы обойти это, мы можем воспользоваться парадигмой Объектно Ориентированного Программирования.
К примеру мы можем создать массив внутри объекта, который будет иметь рекурсивный метод, внутри которого
будет доступ к этому массиву так, что не потребуется передавать этот массив в качестве параметра
для каждого вызова этого метода.

fibonachi_dyn_class.php

Время выполнения этой программы уже приближается к времени выполнения программы основанной на итерациях.
Но всё же для достаточно больших значений n мы будем иметь отставание рекурсивной версии
от его итеративного эквивалента, которое может быть значительным в практическом плане.
Тогда же в чём смысл рекурсии?

Предлагаю вам пока самостоятельно поразмышлять на эту тему. Мы продолжим эту мысль в следущей части.
