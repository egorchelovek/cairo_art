Рисуем фракталы с помощью PHP и Cairo. Часть 1. Основы фрактальной графики

Рисуем фракталы с помощью PHP и Cairo. Часть 2. Фракталы и грамматики Линдемана

Рисуем фракталы с помощью PHP и Cairo. Часть 3. Множества на комплексной плоскости


Фрактал... геометрическая фигура обладающие свойством самоподобия.
Бенуа Мандельброт — отец основатель фрактальной геометрии, бунтарь среди математиков,
впервые подробно описал этот термин в книге Фрактальная геометрия природы, изданной в 1977 году,
которая в значительной степени повлияла на развитие
компьютерной графики, так представила простой способ для генерации
сложных геометрических объектов таких как горы, облака и растения необходимых
для создания фотореалистичных сцен. Кто знает, может быть не попади эта
книга в 1978 году в руки Лорена Карпетнера — сооснователя анимационной компании Pixar, мы бы
так и не увидели всей красоты таких фильмов как "Звёздный путь 6","Аватар", "2012", "Матрица" и т.д.,
в которых задействован движок RenderMan,
содержащий написанный им в соавторстве с Робертом Л. Куком алгоритм Reyes rendering
- задумывавшийся как алгоритм, который может отрисовать всё что ты когда-либо видел.

Фрактал - fractus, что означает дробный. Этим свойством обладют практически все объекты природы.
Начиная с гигантских скоплений Галактик и заканчивая элементарными частицами такими как кварки.
Есть теория голографической Вселенной Девида Бома (ученика Эйнштейна), которая представляет её
как пространственно-временную голограмму, какждый участок которой содержит в себе полную информацию
о всей Вселенной в целом. Согласно этой теории Всё, включая мысли и поступки, происходит из
единой основы и любое изменение в одной части мира неменуемо отражается на всём целом.

Галактики, рельефы планет, океанские волны, облака и молнии, реки, формы растений и животных,
 и даже человеческое тело можно рассматривать как фракталы. Фрактальная геометрия возникла как
 оппозиция против идеальных платоновых тел, которые не могли передать в полной мере всё многообразие
 и сложность природных форм. Простые правила и повторяемость позволили расширить наши представления
 о возможных формах природе и о определении самой размерности. Появилось понятие дробной размерности
 или размерности Хаусдорфа -
 теперь размерность пространства может быть описана вещественными числами, тогда как раньше использовались
 только целые и неотрицательные числа для описания размерности.

 И так мы начинаем рассмотрение основ фрактальной
 графики на PHP. В нашей работе мы будем использовать графическую библиотеку Cairo,
 предназначенную для отрисовки векторной графики, которая написана на языке Си
 и может быть использована так же в связке с такими языками как C++, Python и т.д.,
 что обеспечивает переносимость графического кода между различными платформами.
 Так же к преимуществам Cairo можно отнести качественную отрисовку векторной графики,
 что в купе с другими достоинствами делает эту библиотеку популярной в среде open source.
 При этом мы будем использовать фреймворк GTK, чтобы иметь возможность взаимодействовать
 с нашим кодом через графический интерфейс и просматривать получившиеся изображения.

 Для начала нам придётся создать класс, который будет отвечать за
 создание окна, в котором мы будем рисовать изображение.

 Мы назовём его FractalDrawingWindow и унаследуем его от базового класса GtkWindow,
 который входит во фреймворк GTK. Это позволит нам работать с оконной системой
 нашей операционной системы и отображать сгенерированные изображения фракталов
 внутри неё.

 <?php

 abstract class FractalDrawingWindow extends GtkWindow {

  // глубина рекурсии создаваемого фрактального изображения (по умолчанию)
   protected $recursionDepth = 5;

   // конструктор класса
   public function FractalDrawingWindow() {
     parent::__construct(); // здесь мы вызываем конструктор базового класса,
                            // для успешной инициализации окна


     $this->set_title($this->getName()); // устанавливаем название окна
                                         // по имени фрактала

     // устанавливаем корректный способ выхода из окна
     $this->connect_simple('destroy', array('gtk', 'main_quit'));


     $drawingArea = new GtkDrawingArea(); // создаём область для рисования

     // устанавливаем функцию отображения фрактала для данной области рисования
     $drawingArea->connect('expose_event',array($this,'onExpose'));

     // добавляем созданную область в наше окно
     $this->add($drawingArea);

     // устанавливаем размер окна
     $this->set_default_size(640,480); // по ширине и высоте

     // устаналиваем позицию окна на экране
     $this->set_position(GTK::WIN_POS_CENTER);

     // включаем отображение окна
     $this->show_all(); // здесь начинается запуск алгоритма отрисовки
                        // и отображения фрактала
   }

   // функция экспозиции фрактала
   public function onExpose($darea, $event){
     $context = $darea->window->cairo_create(); // создаём Cairo-контекст для отрисовки
     $this->onDraw($context); // отрисовываем конкретный вид фрактала
   }

   // функция установа глубины рекурсии
   public function setRecursionDepth($recursionDepth){
   // здесь мы ограничиваем глубину рекурсии для избежания segmentation fault
     if($recursionDepth >= 0 && $recursionDepth <= 22){
       $this->recursionDepth = $recursionDepth;
     }
   }

   // мы используем чистые абстрактные методы, чтобы
   abstract public function getName(); // определить названия фракталов
   abstract protected function onDraw($context); // и методы их отрисовки
                                                 // в классах-потомках
 }
 ?>

 Созданный нами класс представляет собой абстрактный класс, предоставляющий
 возможность использования окна GTK для отрисовки. Но данный класс не
 предполагает что именно мы будем рисовать в этом окне, поэтому нам
 нужно создать для него классы-потомки, которые будут определять конкретный
 вид функций названия и способа отрисовки фракталов.


Теперь мы можем приступать к рассмотрению конкретных видов фракталов и способов их рисования.
И начнём мы с фрактала, который получил название в честь немецкого математика, Георга Кантора.

"Ashes to ashes, dust to dust"

 Канторова пыль

 И так рассмотрим следующий код:

 <?php
 include 'drawing_window.php'; // здесь мы подключаем файл с ранее созданным
                               // классом для работы с окнами GTK

// мы создаём класс по конкретному виду фрактала и унаследуем его от класса
// FractalDrawingWindow капсулирующего функци для работы с оконной системой
 class CantorDust extends FractalDrawingWindow {

   // здесь мы определяем функцию, которая будет отображаться в названии окна
   public function getName() {
     return "Cantor dust fractal";
   }

   // здесь мы определяем метод отрисовки фрактала
   protected function onDraw($context){

     // устанавливаем основной цвет для отрисовки
     $context->setSourceRgb(0.4, 0.9, 0.4);

     // запускаем рекурсивную функцию отрисовки фрактала "Канторова пыль"
     $this->draw($context,$this->recursionDepth, 0, 0, $height, floatval($width) / $this->recursionDepth);
   }

   // рекурсивная функция отрисовки
   public function draw($context,$level, $posX, $posY, $sizeX, $sizeY){
     // в параметрах мы передаём начальные позиции по оси X и Y и размеры элементов для каждого шага рекурсии

     // по достижении установленной глубины рекурсии, производим выход из функции отрисовки
     if($level == 0){
       return;
     }

     // вычисляем новый размер и положение элемента по оси X
     $newSizeX = $sizeX / 3;
     $newPosX = $posX + 2 * $newSizeX;

     // рисуем левый прямоугольник
     $context->rectangle($posX,$posY,$newSizeX,$sizeY); // устанавливаем параметры
     $context->fill(); // делаем заливку выделенным цветом, уставноленным ранее в методе onDraw()

     // рисуем правый прямоугольник
     $context->rectangle($newPosX,$posY,$newSizeX,$sizeY);
     $context->fill();

     // запускаем отрисовку следующего уровня рекурсии
     $this->draw($context, $level - 1, $posX, $posY + $sizeY, $newSizeX, $sizeY); // слева
     $this->draw($context, $level - 1, $newPosX, $posY + $sizeY, $newSizeX, $sizeY); // и справа
   }
 }

 // Тест
 $fractal = new CantorDust();  // создаём объект класса для нашего фрактала
 $fractal->setRecursionDepth(15); // устанавливаем глубину рекурсии
 Gtk::main(); // запускаем наш фреймворк в работу
 ?>

 После запуска мы увидим что-то вроде:
 img1

 Это двумерная версия фрактала Канторова пыль, который встречается на практике в области
 обработки речевых сигналов, тогда когда нужно избавиться от постороннего шума...

 Здесь мы используем свойство рекурсии, о котором мы говорили ранее в предыдущих статьях
 по PHP. Это свойство позволяет сделать наш код наглядным и простым и сфокусироваться
 на самой отрисовке. Алгоритм отрисовки достаточно прост: мы берём точку слева и рисуем прямоугольник
 в треть длины всего отрезка с верху, а затем берём точку справа и рисуем такой же отрезок,
 и после повторяем эту операцию для левой и правой части, погружась на всё более глубокий
 уровень рекурсии.

 Для того чтобы нарисовать прямоугольник нам достаточно всего трёх методов вызываемых из объекта
 cairo-context - это rectangle устанавливающий параметры прямоугольника и
 fill - производящий заливку цветом
 а так же setSourceRgb - устанавливающий цвет заливки!

 Ура, теперь можно сделать перерыв и попить чай! Только что мы разобрались в том,
 как рисовать простейший фрактал используя PHP и Cairo!

 Теперь рассмотрим пример по сложнее.


  Дерево Пифагора

  Этот фрактал придумал немецкий учитель математики Альберт Босман в 1942 году и назвал его
  в честь древнегреческого математика и философа Пифагора, потому как каждый уровень этого
  фрактала содержит три соприкасающихся прямоугольника, содержащих между собой прямоугольный треугольник,
  которые традиционно используются для доказательства теоремы Пифагора.

  Построение данного фрактала начинается с квадрата над которым строятся ещё два квадрата,
  уменьшенных на величину корень из двух делённое на два, попарно соединённых между собой общими углами.

  В классическом случае, угол между двумя квадратами близлежащих уровней составляет 45 градусов.
  Тогда как существуют различные вариации данного фрактала, например
  * Обнажённое дерево Пифагора - если каждый квадрат заменяется отрезком
  * Обдувамое ветром дерево Пифагора - если уголы слева и справа отличаются от 45 градусов

  Итак, рассмотрим следующий код:

  <?php
  include 'drawing_window.php'; // как и ранее мы подключаем класс FractalDrawingWindow

  // от которого мы унаследуем методы для работы с оконной системой
  class PythagorianTree extends FractalDrawingWindow {

    // определим метод для отображения имени фрактала в заголовке окна
    public function getName() {
      return "Pythagorian tree fractal";
    }

    // и метод для отрисовки самого фрактала
    protected function onDraw($context){
      $context->setSourceRgb(0.4, 0.9, 0.4); // определим базовый цвет отрисовки

      // запустим рекурсивную функцию отрисовки нашего фрактала
      $this->draw($context, $this->recursionDepth, $this->get_size()[0]/2 - 50, $this->get_size()[1], $this->get_size()[0]/2 +50, $this->get_size()[1]);
    }

    // рекурсивная функция отрисовки
    public function draw($context, $depth, $x1, $y1, $x2, $y2){

      // производим ограничение на глубину рекурсии
      if($depth == 0) {
        return;
      }

      // вычисляем относительные смещения точек квадрата по осям X и Y
      $dx = $x2-$x1;
      $dy = $y1-$y2;

      // изменяем кординаты точек квадрата на данном уровне рекурсии
      $x3 = $x2 - $dy;
      $y3 = $y2 - $dx;
      $x4 = $x1 - $dy;
      $y4 = $y1 - $dx;
      $x5 = $x4 + floatval(($dx - $dy))*0.5;
      $y5 = $y4 - floatval(($dx + $dy))*0.5;

      // рисуем квадрат
      $context->MoveTo($x1, $y1); // смещаемся к координате (x1,y1) это первая точка
      $context->LineTo($x2, $y2); // создаём отрезок из точки (x1,y1) к точке (x2,y2)
      $context->LineTo($x3, $y3); // и т.д.
      $context->LineTo($x4, $y4); // до последней вычисленной точки
      $context->closePath(); // закрываем линию возвращаясь в исходную точку (x1,y1)
      // устанавливаем цвет на новом уровне рекурсии
      $context->setSourceRgb(1.0 - floatval($this->recursionDepth-$depth)/$this->recursionDepth, floatval($this->recursionDepth-$depth)/$this->recursionDepth, 0.0);
      // делаем заливку цветом
      $context->fill();

      $depth--; // инкрементируем счётчик уровня рекурсии
      $this->draw($context, $depth, $x4, $y4, $x5, $y5); // рисуем квадрат слева
      $this->draw($context, $depth, $x5, $y5, $x3, $y3); // рисуем квадрат справа от исходного
    }
  }

  // Тест
  $fractal = new PythagorianTree(); // создание объекта окна GTK с фракталом
  $fractal->setRecursionDepth(10); // установ уровня рекурсии
  Gtk::main(); // запуск фреймворка
  ?>

  После запуска этого кода, можно будет созерцать следующую картину:
  omg2

  Чудесно! Теперь мы видим, что можно создавать достаточно сложные фигуры сравнительно простыми методами,
  используя свойства рекурсии и графические примитивы билиотеки Cairo!

  Ну и на последок я хотел бы рассмотреть следующий фрактал.

 Дракон Хартера - Хейтуэя

 Дракон Хратера - Хейтуэя, так же известный как дракон Хартера был впервые представлен в 1967 году
 Мартином Гарднеров в журнале "Scientific American". Cвоим названием он обязан Джону Хатуэю и Вильяму Хартеру
 - двум физикам из NASA впервые исследовшим этот фрактал. К сожалению имя третьего физика - Брюса Бэнкса
 обычно опускают и вместо него ставят прочерк (некоторые люди к сожалению особенно подвержены действию закона Мёрфи).

 Итак рассмотрим следующий код:

 <?php
 include 'drawing_window.php';

 class DragonCurve extends FractalDrawingWindow {

   public function getName() {
     return "Dragon curve fractal";
   }

   protected function onDraw($context){
     // здесь в отличие от предыдущих двух случаев мы используем итеративный метод
     // создания последовательности операций отрисовки
     $turns = $this->getSequence($this->recursionDepth);
     $startAngle = -$this->recursionDepth * 3.14 / 4;
     $side = 400 / pow(2, $this->recursionDepth / 2.);
     $this->draw($context, $turns, $startAngle, $side, $this->get_size()[0]/2, $this->get_size()[1]/2);
   }

   // метод получения последовательности операций отрисовки дракона Хартера
   public function getSequence($depth){
     $seq = array(); // создаём исходный пустой массив
     for($i =0; $i < $depth; $i++) {
       $copy = $seq; // создаём копию данного массива
       $copy = array_reverse($copy); // инвертируем порядок элементов массива на инверсный (элементы в начале становяться в конец и наоборот)
       // добавляем к исходному массиву код направления угла поворота линии для данного фрактала
       array_push($seq,1);
       // добавляем к исходому массиву реверсную копию инвертированных направлений углов поворота с предыдущего уровня итерации
       foreach($copy as $val){
         array_push($seq,-$val);
       }
     }
     // возвращаем последовательность направлений углов поворота линий данного фрактала
     return $seq;
   }

   // определяем функцию отрисовки для полученной последовательности направлений
   public function draw($context, $turns, $startAngle, $side, $x1, $y1){
     $angle = $startAngle; // устанавливаем начальный угол
     $x2 = $x1 + intval(cos($angle)*$side); // производим поворот исходной точеки прямой
     $y2 = $y1 + intval(sin($angle)*$side);
     $context->setSourceRgb(0.4, 0.4, 0.9); // устанавливаем исходный цвет линии

     // переходим к точке x1,y1
     $context->moveTo($x1,$y1);
     // строим отрезок к точке x2,y2
     $context->lineTo($x2,$y2);
     // производим отрисовку
     $context->stroke();
     // переходим к следующей точке
     $x1 = $x2;
     $y1 = $y2;
     foreach($turns as $turn){
       $angle += $turn * 3.14 / 2; // изменяем угол поворота на 90 градусов в соотвествии
                                   // с рассчитанной заранее последовательностью

       // производим поворот и отрисовку фигуры на новом уровне итерации
       $x2 = $x1 + intval(cos($angle)*$side);
       $y2 = $y1 + intval(sin($angle)*$side);
       $context->moveTo($x1,$y1);
       $context->lineTo($x2,$y2);
       $context->stroke();
       $x1 = $x2;
       $y1 = $y2;
     }
   }
 }

 // Тест
 $fractal = new DragonCurve();
 $fractal->setRecursionDepth(15);
 Gtk::main();
 ?>

 
